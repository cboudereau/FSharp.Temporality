{"name":"Outatime","tagline":"","body":"# Outatime [![Build status](https://ci.appveyor.com/api/projects/status/v3f2gj9602e82ia4?svg=true)](https://ci.appveyor.com/project/cboudereau/outatime) \r\n\r\nWhen you have to deal with price, restrictions or all kind of values changing over the time, it becomes difficult to reduce the amount of data of your API If you don't have a strategy to merge the values.\r\n\r\n## Maths at Rescue! What are the common value over the time to avoid data repetition\r\nOutatime has differents principles in order to have the correct design and algorithms :\r\n\r\n## Applicative functor at the rescue but it is promise it is not difficult it is an evidence!\r\n```fsharp\r\nmodule ApplicativeFunctorTests\r\n\r\nopen Bdd\r\nopen Xunit\r\nopen Outatime\r\n\r\nlet jan15 d = DateTime(2015, 1, d)\r\n\r\ntype Opening = Opened | Closed\r\ntype Departure = OpenedToDeparture | ClosedToDeparture\r\ntype Availability = Availability of int\r\ntype Price = Price of decimal\r\n\r\ntype Rate = \r\n    { departure: Departure\r\n      availability: Availability\r\n      price: Price }\r\n\r\ntype RateAvailability = \r\n    | Closed\r\n    | Opened of Rate\r\n\r\n[<Fact>]\r\nlet ``given multiple temporaries, when apply a function on this temporaries then expect applied function on any intersection``()=\r\n    let ``transform temporaries to rate availability domain`` opening departure availability price = \r\n        match opening with\r\n        | (Opening.Opened) -> \r\n            RateAvailability.Opened \r\n                { departure=departure; availability=availability; price=price }\r\n        | (Opening.Closed) -> \r\n            RateAvailability.Closed\r\n\r\n    let ``transform temporaries into request`` temporaries = \r\n        let request t = \r\n            match t.value with\r\n            | None -> \r\n                sprintf \"%O = No Request (May be put a state monad here)\" t.period\r\n            | Some Closed -> \r\n                sprintf \"%O = Closed\" t.period\r\n            | Some (Opened rate) -> \r\n                let (Availability a) = rate.availability\r\n                let (Price p) = rate.price\r\n                let d = \r\n                    match rate.departure with\r\n                    | ClosedToDeparture -> \"closed to departure\"\r\n                    | OpenedToDeparture -> \"opened to departure\"\r\n\r\n                sprintf \"%O = Opened with %i of availibility at %.2f price and %s\" t.period a p d\r\n            \r\n        temporaries \r\n        |> Seq.map request\r\n        |> Seq.toList\r\n\r\n    When\r\n        ``transform temporaries to rate availability domain``\r\n        <!> [ jan15 4  => jan15 5  := Opening.Opened\r\n              jan15 5  => jan15 20 := Opening.Closed ]\r\n\r\n        <*> [ jan15 2  => jan15 15 := OpenedToDeparture\r\n              jan15 16 => jan15 18 := OpenedToDeparture\r\n              jan15 18 => jan15 23 := ClosedToDeparture ]\r\n\r\n        <*> [ jan15 1  => jan15 22 := Availability 10 ]\r\n\r\n        <*> [ jan15 1  => jan15 22 := Price 120m ]\r\n        |> ``transform temporaries into request``\r\n    |> Expect \r\n        [ \"[2015/01/01; 2015/01/04[ = No Request (May be put a state monad here)\"\r\n          \"[2015/01/04; 2015/01/05[ = Opened with 10 of availibility at 120.00 price and opened to departure\"\r\n          \"[2015/01/05; 2015/01/15[ = Closed\"\r\n          \"[2015/01/15; 2015/01/16[ = No Request (May be put a state monad here)\"\r\n          \"[2015/01/16; 2015/01/18[ = Closed\"\r\n          \"[2015/01/18; 2015/01/20[ = Closed\"\r\n          \"[2015/01/20; 2015/01/23[ = No Request (May be put a state monad here)\" ]\r\n```\r\n\r\n### Period \r\nBased on Mathematics Interval applied to Date with a Start Date and an End Date. The Interval is Half Open, then the period from 01/01 to 02/01 has one day duration.\r\n\r\n### Temporary\r\nIs the value at a Period\r\n\r\n## Features\r\n### Merge\r\nWhen value are equals and period intersects, then the temporary is merged and number of temporaries on a temporal decrease. Eg Given a value \"toto\" on Given periods 01/01 -> 02/01; 02/01 -> 03/01, then the corresponding merge is \"toto\" on Given periods 01/01 -> 03/01. Sample : https://github.com/cboudereau/Outatime/blob/master/Outatime.Test/TemporalMergeProperties.fs\r\n\r\n```fsharp\r\nopen Outatime\r\nopen Bdd\r\nopen Xunit\r\n\r\nlet jan15 n = (DateTime(2015,1,n))\r\nlet ``I want to merge temporaries`` = Outatime.merge >> Seq.toList\r\n\r\n[<Fact>]\r\nlet ``given contiguous temporary expect a merged temporary``()=\r\n    When ``I want to merge temporaries`` \r\n    |> With \r\n        [ jan15 01 => jan15 02 := \"Hello\"\r\n          jan15 02 => jan15 05 := \"Hello\"\r\n          jan15 05 => jan15 10 := \"World\"\r\n          jan15 10 => jan15 20 := \"World\" ]\r\n    |> Expect\r\n        [ jan15 01 => jan15 05 := \"Hello\"\r\n          jan15 05 => jan15 20 := \"World\" ]\r\n```\r\n\r\n### Split\r\nWhen need to crop to a period..\r\n\r\n```fsharp\r\nopen Outatime\r\nopen Xunit\r\nopen Bdd\r\n\r\nlet jan15 n = (DateTime(2015,1,n))\r\nlet days n = TimeSpan.FromDays(float n)\r\n\r\nlet ``I want to split temporaries`` days temporaries = Outatime.split days temporaries |> Seq.toList\r\nlet ``five days`` = days 5\r\n\r\n[<Fact>]\r\nlet ``given temporaries for a large period when split for n days expect temporary with n day max period length``()=\r\n    When ``I want to split temporaries`` \r\n    |> For ``five days``\r\n    |> With [ jan15 01 => jan15 11 := \"HelloWorld\" ]\r\n    |> Expect\r\n        [ jan15 01 => jan15 06 := \"HelloWorld\"\r\n          jan15 06 => jan15 11 := \"HelloWorld\" ]\r\n```\r\n\t\r\n### Clamp\r\nGiven a period and get the corresponding temporaries.\r\n\r\n## QA\r\n### Writen with property based testing driven dev\r\nOutatime is fully written with property based testing and FSCheck https://github.com/fscheck/FsCheck\r\nAll properties are based on Interval Mathematics principles : https://github.com/cboudereau/Outatime/blob/master/Outatime.Test/PeriodProperties.fs\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}