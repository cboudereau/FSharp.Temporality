{"name":"Outatime","tagline":"","body":"# Outatime [![Build status](https://ci.appveyor.com/api/projects/status/v3f2gj9602e82ia4?svg=true)](https://ci.appveyor.com/project/cboudereau/outatime) [![NuGet Status](http://img.shields.io/nuget/v/Outatime.svg?style=flat)](https://www.nuget.org/packages/Outatime/)\r\n\r\n![Outatime] (https://raw.githubusercontent.com/cboudereau/Outatime/master/intro.jpg)\r\n\r\n=====\r\n\r\n## Introduction\r\nWhen you have a lots of values changing over the time in a planning, it become difficult to deal with it day per day. The solution is to group the same values and merge period.\r\nOn way is having the temporary (type containing value on a period) everywhere but: you have the domain complexity everywhere and if you have to compose another domain you will have more wrapped types.\r\n\r\nTo simplify and compose functionalities, Outatime give an applicative functor approach. \r\nInstead of having the wrapped type everywhere, a function containing all values as parameter is binded to values changing over the time. The domain is out of the time\r\n\r\n## How it works\r\nBy using merge function, intersection period, and finding the largest period for missing values, a function is applied each time you give the temporaries. \r\nEach time the value is the function applied (given a function with n parameter, expect a function with n-1 parameter).\r\n\r\n## Maths at Rescue! What are the common value over the time to avoid data repetition\r\nOutatime has differents principles in order to have the correct design and algorithms\r\n\r\n### Period \r\nBased on Mathematics Interval applied to Date with a Start Date and an End Date. The Interval is Half Open, then the period from 01/01 to 02/01 has one day duration.\r\n\r\n### Temporary\r\nIs the value at a Period\r\n\r\n### Merge\r\nWhen value are equals and period intersects, then the temporary is merged and number of temporaries on a temporal decrease. Eg Given a value \"toto\" on Given periods 01/01 -> 02/01; 02/01 -> 03/01, then the corresponding merge is \"toto\" on Given periods 01/01 -> 03/01. Sample : https://github.com/cboudereau/Outatime/blob/master/src/Outatime.Test/MergeTests.fs\r\n\r\n```fsharp\r\nopen Outatime\r\nopen Bdd\r\nopen Xunit\r\n\r\nlet jan15 n = (DateTime(2015,1,n))\r\nlet ``I want to merge temporaries`` = Outatime.merge >> Seq.toList\r\n\r\n[<Fact>]\r\nlet ``given contiguous temporary expect a merged temporary``()=\r\n    When ``I want to merge temporaries`` \r\n    |> With \r\n        [ jan15 01 => jan15 02 := \"Hello\"\r\n          jan15 02 => jan15 05 := \"Hello\"\r\n          jan15 05 => jan15 10 := \"World\"\r\n          jan15 10 => jan15 20 := \"World\" ]\r\n    |> Expect\r\n        [ jan15 01 => jan15 05 := \"Hello\"\r\n          jan15 05 => jan15 20 := \"World\" ]\r\n```\r\n\r\n### Split\r\nWhen need to crop to a period..\r\n\r\n```fsharp\r\nopen Outatime\r\nopen Xunit\r\nopen Bdd\r\n\r\nlet jan15 n = (DateTime(2015,1,n))\r\nlet days n = TimeSpan.FromDays(float n)\r\n\r\nlet ``I want to split temporaries`` days temporaries = Outatime.split days temporaries |> Seq.toList\r\nlet ``five days`` = days 5\r\n\r\n[<Fact>]\r\nlet ``given temporaries for a large period when split for n days expect temporary with n day max period length``()=\r\n    When ``I want to split temporaries`` \r\n    |> For ``five days``\r\n    |> With [ jan15 01 => jan15 11 := \"HelloWorld\" ]\r\n    |> Expect\r\n        [ jan15 01 => jan15 06 := \"HelloWorld\"\r\n          jan15 06 => jan15 11 := \"HelloWorld\" ]\r\n```\r\n\t\r\n### Clamp\r\nGiven a period and get the corresponding temporaries.\r\n\r\n## QA\r\n### Writen with property based testing driven dev\r\nOutatime is fully written with property based testing and FSCheck https://github.com/fscheck/FsCheck\r\nAll properties are based on Interval Mathematics principles : https://github.com/cboudereau/Outatime/blob/master/src/Outatime.Test/PeriodProperties.fs\r\n\r\n## Applicative functor\r\nAs describe in the introduction part, an applicative functor can be use in order to have a domain out of the time.\r\n\r\n```fsharp\r\nmodule ReadmeSample\r\n\r\nopen Outatime\r\nopen Xunit\r\n\r\n//Simple BDD functions\r\nlet When f = f\r\nlet With v f = f v\r\nlet For = With\r\nlet And = With\r\nlet Then check expected = check expected\r\n\r\nlet shouldEqual<'a> (expected:'a) (actual:'a) = Assert.Equal(expected, actual)\r\n\r\nlet Expect<'a> = Then shouldEqual<'a>\r\n\r\nlet shouldBeEmpty actual = Assert.Equal(0, actual |> Seq.length)\r\n\r\nlet jan15 d = DateTime(2015, 1, d)\r\n\r\n//A domain sample\r\ntype Opening = Opened | Closed\r\ntype Departure = OpenedToDeparture | ClosedToDeparture\r\ntype Availability = Availability of int\r\ntype Price = Price of decimal\r\n\r\ntype Rate = \r\n    { Departure: Departure\r\n      Availability: Availability\r\n      Price: Price }\r\n\r\ntype RateAvailability = \r\n    | Closed\r\n    | Opened of Rate\r\n\r\nlet ``transform temporaries to rate availability domain`` openingO departureO availabilityO priceO = \r\n    match openingO, departureO, availabilityO, priceO with\r\n    | Some opening, Some departure, Some availability, Some price -> \r\n        match opening with\r\n        | Opening.Opened ->\r\n            RateAvailability.Opened \r\n                { Departure=departure; Availability=availability; Price=price }\r\n            |> Some\r\n        | Opening.Closed -> Some RateAvailability.Closed\r\n    | _ -> None\r\n\r\nlet ``transform temporaries into request`` temporaries = \r\n    let request t = \r\n        match t.Value with\r\n        | None -> \r\n            sprintf \"%O = No Request (May be put a state monad here for not contiguous case)\" t.Period\r\n        | Some Closed -> \r\n            sprintf \"%O = Closed\" t.Period\r\n        | Some (Opened rate) -> \r\n            let (Availability a) = rate.Availability\r\n            let (Price p) = rate.Price\r\n            let d = \r\n                match rate.Departure with\r\n                | ClosedToDeparture -> \"closed to departure\"\r\n                | OpenedToDeparture -> \"opened to departure\"\r\n\r\n            sprintf \"%O = Opened with %i of availibility at %.2f price and %s\" t.Period a p d\r\n        \r\n    temporaries \r\n    |> Seq.map request\r\n    |> Seq.toList\r\n\r\n[<Fact>]\r\nlet ``given temporaries with no intersections or empty periods expect the largest period with none value``()=\r\n    When\r\n        ``transform temporaries to rate availability domain``\r\n        <!> [ jan15 4  => jan15 4  := Opening.Opened\r\n              jan15 5  => jan15 5 := Opening.Closed ]\r\n\r\n        <*> [ jan15 1 => jan15 16 := OpenedToDeparture\r\n              jan15 2  => jan15 2 := OpenedToDeparture ]\r\n\r\n        <*> [ jan15 1  => jan15 1 := Availability 10 ]\r\n\r\n        <*?> [ jan15 3  => jan15 3 := Price 120m ]\r\n        |> ``transform temporaries into request``\r\n    |> Expect [\"[2015/01/01; 2015/01/16[ = No Request (May be put a state monad here for not contiguous case)\"]\r\n    \r\n\r\n[<Fact>]\r\nlet ``given multiple temporaries, when apply a function on this temporaries then expect applied function on any intersection``()=\r\n\r\n    When\r\n        ``transform temporaries to rate availability domain``\r\n        <!> [ jan15 4  => jan15 5  := Opening.Opened\r\n              jan15 5  => jan15 20 := Opening.Closed ]\r\n\r\n        <*> [ jan15 2  => jan15 15 := OpenedToDeparture\r\n              jan15 16 => jan15 18 := OpenedToDeparture\r\n              jan15 18 => jan15 23 := ClosedToDeparture ]\r\n\r\n        <*> [ jan15 1  => jan15 22 := Availability 10 ]\r\n\r\n        <*?> [ jan15 1  => jan15 22 := Price 120m ]\r\n        |> ``transform temporaries into request``\r\n    |> Expect \r\n        [ \"[2015/01/01; 2015/01/04[ = No Request (May be put a state monad here for not contiguous case)\"\r\n          \"[2015/01/04; 2015/01/05[ = Opened with 10 of availibility at 120.00 price and opened to departure\"\r\n          \"[2015/01/05; 2015/01/15[ = Closed\"\r\n          \"[2015/01/15; 2015/01/16[ = No Request (May be put a state monad here for not contiguous case)\"\r\n          \"[2015/01/16; 2015/01/20[ = Closed\"\r\n          \"[2015/01/20; 2015/01/23[ = No Request (May be put a state monad here for not contiguous case)\" ]\r\n```","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}